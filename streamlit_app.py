'''
Interface de Usu√°rio (Frontend) para o Agent_BI.
Vers√£o integrada que n√£o depende de API externa.
'''
import streamlit as st
import uuid
import pandas as pd
import logging
from core.auth import login, sessao_expirada

# Importa√ß√µes do backend para integra√ß√£o direta - DIAGN√ìSTICO DETALHADO
import_status = {}
BACKEND_AVAILABLE = True

# Testar cada import individualmente para diagn√≥stico
try:
    from core.config.settings import settings
    import_status["settings"] = "‚úÖ OK"
except Exception as e:
    import_status["settings"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

try:
    from langchain_core.messages import HumanMessage
    import_status["langchain_core"] = "‚úÖ OK"
except Exception as e:
    import_status["langchain_core"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

try:
    from core.llm_adapter import OpenAILLMAdapter
    import_status["llm_adapter"] = "‚úÖ OK"
except Exception as e:
    import_status["llm_adapter"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

try:
    from core.connectivity.parquet_adapter import ParquetAdapter
    import_status["parquet_adapter"] = "‚úÖ OK"
except Exception as e:
    import_status["parquet_adapter"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

try:
    from core.agents.code_gen_agent import CodeGenAgent
    import_status["code_gen_agent"] = "‚úÖ OK"
except Exception as e:
    import_status["code_gen_agent"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

try:
    from core.graph.graph_builder import GraphBuilder
    import_status["graph_builder"] = "‚úÖ OK"
except Exception as e:
    import_status["graph_builder"] = f"‚ùå {str(e)}"
    BACKEND_AVAILABLE = False

# Log detalhado apenas para debugging
if not BACKEND_AVAILABLE:
    logging.warning("DIAGN√ìSTICO DE IMPORTS:")
    for component, status in import_status.items():
        logging.warning(f"  {component}: {status}")

# --- Autentica√ß√£o ---
if "authenticated" not in st.session_state:
    st.session_state.authenticated = False

if not st.session_state.authenticated or sessao_expirada():
    st.session_state.authenticated = False
    login()
else:
    # --- Configura√ß√£o da P√°gina ---
    st.set_page_config(page_title="Agent_BI", page_icon="üìä", layout="wide")
    st.title("üìä Agent_BI - Assistente Inteligente")

    # --- Inicializa√ß√£o do Backend Integrado ---
    @st.cache_resource
    def initialize_backend():
        """Inicializa os componentes do backend uma √∫nica vez"""
        debug_info = []

        # Debug 1: Verificar imports com detalhes
        debug_info.append(f"BACKEND_AVAILABLE: {BACKEND_AVAILABLE}")
        if not BACKEND_AVAILABLE:
            user_role = st.session_state.get('role', '')
            if user_role == 'admin':
                with st.sidebar:
                    st.error("‚ùå Imports do backend falharam")
                    st.write("**Diagn√≥stico detalhado:**")
                    for component, status in import_status.items():
                        if "‚úÖ" in status:
                            st.success(f"{component}: {status}")
                        else:
                            st.error(f"{component}: {status}")
            else:
                with st.sidebar:
                    st.error("‚ùå Sistema temporariamente indispon√≠vel")
            return None

        try:
            # Debug 2: Verificar secrets
            api_key = None
            secrets_status = "‚ùå Falhou"
            try:
                debug_info.append("Tentando acessar st.secrets...")
                api_key = st.secrets.get("OPENAI_API_KEY")
                if api_key and api_key.startswith("sk-"):
                    secrets_status = "‚úÖ OK"
                    debug_info.append(f"‚úÖ Secrets OpenAI: OK ({api_key[:10]}...)")
                else:
                    debug_info.append(f"‚ùå Secrets OpenAI: Inv√°lida ou vazia")
                    debug_info.append(f"‚ùå Valor recebido: {str(api_key)[:20] if api_key else 'None'}")
            except Exception as e:
                debug_info.append(f"‚ùå Secrets erro: {str(e)}")
                debug_info.append(f"‚ùå Tipo erro: {type(e).__name__}")

            # Debug 3: Fallback para settings
            if not api_key or not api_key.startswith("sk-"):
                try:
                    debug_info.append("Tentando carregar settings...")
                    api_key = settings.OPENAI_API_KEY.get_secret_value()
                    debug_info.append(f"Settings OpenAI: OK")
                except Exception as e:
                    debug_info.append(f"‚ùå Settings erro completo: {str(e)}")
                    debug_info.append(f"‚ùå Tipo do erro: {type(e).__name__}")
                    # Se settings falhar, pode ser problema com vari√°veis DB obrigat√≥rias

            if not api_key or not api_key.startswith("sk-"):
                debug_info.append("‚ùå CRITICAL: OPENAI_API_KEY n√£o encontrada")
                debug_info.append("üí° SOLU√á√ÉO: Configure OPENAI_API_KEY nos secrets do Streamlit Cloud")
                raise ValueError("OPENAI_API_KEY n√£o encontrada em secrets nem settings")

            # Debug 4: Inicializar LLM
            debug_info.append("Inicializando LLM...")
            llm_adapter = OpenAILLMAdapter(api_key=api_key)
            debug_info.append("‚úÖ LLM OK")

            # Debug 5: Inicializar Parquet
            debug_info.append("Inicializando Parquet...")
            import os
            parquet_path = os.path.join(os.getcwd(), "data", "parquet", "admatao.parquet")
            if not os.path.exists(parquet_path):
                # Criar dados mock para cloud se arquivo n√£o existir
                import pandas as pd
                mock_data = pd.DataFrame({
                    'codigo': [59294, 12345, 67890],
                    'descricao': ['Produto Exemplo 1', 'Produto Exemplo 2', 'Produto Exemplo 3'],
                    'preco': [99.90, 149.50, 79.30],
                    'categoria': ['Categoria A', 'Categoria B', 'Categoria A']
                })
                os.makedirs(os.path.dirname(parquet_path), exist_ok=True)
                mock_data.to_parquet(parquet_path)
                debug_info.append("‚ö†Ô∏è Arquivo parquet n√£o encontrado - criado dados mock")
            parquet_adapter = ParquetAdapter(file_path=parquet_path)
            debug_info.append("‚úÖ Parquet OK")

            # Debug 6: Inicializar CodeGen
            debug_info.append("Inicializando CodeGen...")
            code_gen_agent = CodeGenAgent(llm_adapter=llm_adapter)
            debug_info.append("‚úÖ CodeGen OK")

            # Debug 7: Construir Grafo
            debug_info.append("Construindo grafo...")
            graph_builder = GraphBuilder(
                llm_adapter=llm_adapter,
                parquet_adapter=parquet_adapter,
                code_gen_agent=code_gen_agent
            )
            agent_graph = graph_builder.build()
            debug_info.append("‚úÖ Grafo OK")

            debug_info.append("üéâ Backend inicializado com sucesso!")

            return {
                "llm_adapter": llm_adapter,
                "parquet_adapter": parquet_adapter,
                "code_gen_agent": code_gen_agent,
                "agent_graph": agent_graph
            }

        except Exception as e:
            debug_info.append(f"‚ùå ERRO CR√çTICO: {str(e)}")
            debug_info.append(f"‚ùå Tipo do erro: {type(e).__name__}")
            debug_info.append(f"‚ùå Linha do erro: {e.__traceback__.tb_lineno if e.__traceback__ else 'unknown'}")

            # Diagn√≥stico espec√≠fico para erros comuns
            if "ValidationError" in str(type(e)):
                debug_info.append("üí° CAUSA PROV√ÅVEL: Vari√°veis obrigat√≥rias faltando em settings")
            elif "ImportError" in str(type(e)) or "ModuleNotFoundError" in str(type(e)):
                debug_info.append("üí° CAUSA PROV√ÅVEL: Depend√™ncia faltando nos requirements")
            elif "FileNotFoundError" in str(type(e)):
                debug_info.append("üí° CAUSA PROV√ÅVEL: Arquivo parquet n√£o encontrado")

            # Mostrar debug completo na sidebar APENAS para admins
            user_role = st.session_state.get('role', '')
            if user_role == 'admin':
                with st.sidebar:
                    st.error("üö® Backend Error (Admin)")
                    st.write("**Debug Log:**")
                    for info in debug_info:
                        if "‚úÖ" in info:
                            st.success(info)
                        elif "‚ùå" in info:
                            st.error(info)
                        else:
                            st.info(info)

                    st.write("**Erro Completo:**")
                    st.code(str(e))
            else:
                with st.sidebar:
                    st.error("‚ùå Sistema temporariamente indispon√≠vel")

            return None

    # Inicializar backend
    backend_components = initialize_backend()

    # Salvar no session_state para acesso em outras partes
    if backend_components:
        st.session_state.backend_components = backend_components
        user_role = st.session_state.get('role', '')
        if user_role == 'admin':
            with st.sidebar:
                st.success("‚úÖ Backend inicializado!")
    else:
        st.session_state.backend_components = None
        user_role = st.session_state.get('role', '')
        if user_role == 'admin':
            with st.sidebar:
                st.error("‚ùå Backend falhou")

    # --- Logout Button ---
    with st.sidebar:
        st.write(f"Bem-vindo, {st.session_state.get('username', '')}!")
        if st.button("Logout"):
            st.session_state.authenticated = False
            st.session_state.username = ""
            st.session_state.role = ""
            # Clear chat history on logout
            st.session_state.messages = [
                {
                    "role": "assistant",
                    "content": {
                        "type": "text",
                        "content": "Voc√™ foi desconectado. Fa√ßa login para continuar."
                    }
                }
            ]
            st.rerun()


    # --- Estado da Sess√£o ---

    if 'session_id' not in st.session_state:
        st.session_state.session_id = str(uuid.uuid4())
    if 'messages' not in st.session_state:
        st.session_state.messages = [
            {
                "role": "assistant",
                "content": {
                    "type": "text",
                    "content": "Ol√°! Como posso ajudar voc√™ com seus dados hoje?"
                }
            }
        ]

    # --- Fun√ß√µes de Intera√ß√£o ---
    def query_backend(user_input: str):
        '''Processa a query diretamente usando o backend integrado.'''
        # üìù GARANTIR que a pergunta do usu√°rio seja sempre preservada
        user_message = {"role": "user", "content": {"type": "text", "content": user_input}}
        st.session_state.messages.append(user_message)

        with st.spinner("O agente est√° a pensar..."):
            try:
                if not backend_components or not backend_components.get("agent_graph"):
                    # Fallback: resposta simples se backend n√£o dispon√≠vel
                    agent_response = {
                        "type": "text",
                        "content": f"‚ö†Ô∏è Sistema est√° sendo inicializado. Tente novamente em alguns segundos.\n\nSe o problema persistir, contate o administrador.",
                        "user_query": user_input
                    }
                else:
                    # Usar backend integrado (similar ao main.py)
                    initial_state = {"messages": [HumanMessage(content=user_input)]}
                    final_state = backend_components["agent_graph"].invoke(initial_state)
                    agent_response = final_state.get("final_response", {})

                    # Garantir que a resposta inclui informa√ß√µes da pergunta
                    if "user_query" not in agent_response:
                        agent_response["user_query"] = user_input

                # ‚úÖ GARANTIR estrutura correta da resposta
                assistant_message = {"role": "assistant", "content": agent_response}
                st.session_state.messages.append(assistant_message)

                # üîç LOG da resposta (removido print para evitar problemas de encoding)
                # print(f"AGENT RESPONSE ADDED: Type={agent_response.get('type', 'unknown')} - Total messages: {len(st.session_state.messages)}")

            except Exception as e:
                # Tratamento de erro local
                error_content = {
                    "type": "error",
                    "content": f"‚ùå Erro ao processar consulta: {str(e)}\n\nVerifique se a chave OPENAI_API_KEY est√° configurada corretamente nos secrets."
                }
                st.session_state.messages.append({"role": "assistant", "content": error_content})

        st.rerun()

    # --- Renderiza√ß√£o da Interface ---
    # üîç DEBUG: Mostrar hist√≥rico de mensagens na sidebar (apenas para desenvolvimento)
    with st.sidebar:
        st.write(f"**Total de mensagens:** {len(st.session_state.messages)}")
        if st.checkbox("Mostrar hist√≥rico debug"):
            for i, msg in enumerate(st.session_state.messages):
                st.write(f"**{i+1}. {msg['role'].title()}:**")
                content_preview = str(msg.get('content', {}))[:100] + "..." if len(str(msg.get('content', {}))) > 100 else str(msg.get('content', {}))
                st.write(f"{content_preview}")

    # üí¨ RENDERIZAR hist√≥rico de conversas
    for i, msg in enumerate(st.session_state.messages):
        try:
            with st.chat_message(msg["role"]):
                response_data = msg.get("content", {})

                # ‚úÖ Garantir que response_data seja um dicion√°rio
                if not isinstance(response_data, dict):
                    response_data = {"type": "text", "content": str(response_data)}

                response_type = response_data.get("type", "text")
                content = response_data.get("content", "Conte√∫do n√£o dispon√≠vel")

            # üîç DEBUG: Log de renderiza√ß√£o (removido print para evitar problemas)
            # if msg["role"] == "user":
            #     print(f"RENDERING USER MSG {i+1}: '{content}'")
            # else:
            #     print(f"RENDERING ASSISTANT MSG {i+1}: Type={response_type}")
            
            # üìà RENDERIZAR GR√ÅFICOS
            if response_type == "chart":
                import json
                import plotly.graph_objects as go

                # üìù Mostrar contexto da pergunta que gerou o gr√°fico
                user_query = response_data.get("user_query")
                if user_query:
                    st.caption(f"üìù Pergunta: {user_query}")

                try:
                    if isinstance(content, str):
                        # Se content √© string JSON, parse para objeto
                        chart_data = json.loads(content)
                    else:
                        # Se content j√° √© dict, usa diretamente
                        chart_data = content

                    # Cria figura Plotly a partir do JSON
                    fig = go.Figure(chart_data)
                    st.plotly_chart(fig, use_container_width=True)
                    st.success("‚úÖ Gr√°fico gerado com sucesso!")
                except Exception as e:
                    st.error(f"Erro ao renderizar gr√°fico: {e}")
                    st.write("Dados do gr√°fico:", content)
            elif response_type == "data" and isinstance(content, list):
                # üìù Mostrar contexto da pergunta que gerou os dados
                user_query = response_data.get("user_query")
                if user_query:
                    st.caption(f"üìù Pergunta: {user_query}")

                if content:
                    st.dataframe(pd.DataFrame(content))
                    st.info(f"üìä {len(content)} registros encontrados")
                else:
                    st.warning("‚ö†Ô∏è Nenhum dado encontrado para a consulta.")
            elif response_type == "clarification":
                st.markdown(content.get("message"))
                choices = content.get("choices", {})
                for choice_category, choice_list in choices.items():
                    for choice in choice_list:
                        if st.button(choice, key=f"btn_{choice}_{uuid.uuid4()}"):
                            query_backend(choice)
            else:
                # üìù Para respostas de texto, tamb√©m mostrar contexto se dispon√≠vel
                user_query = response_data.get("user_query")
                if user_query and msg["role"] == "assistant":
                    st.caption(f"üìù Pergunta: {user_query}")

                st.write(content)

        except Exception as e:
            # ‚ùå Tratamento de erro na renderiza√ß√£o
            st.error(f"Erro ao renderizar mensagem {i+1}: {str(e)}")
            st.write(f"Dados da mensagem: {msg}")

    if prompt := st.chat_input("Fa√ßa sua pergunta..."):
        query_backend(prompt)
